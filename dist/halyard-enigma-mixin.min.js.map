{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///halyard-enigma-mixin.min.js","webpack:///webpack/bootstrap c92312525bb2357f1de0","webpack:///./src/enigma-mixin/halyard-enigma-mixin.js","webpack:///./src/enigma-mixin/utils.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","createErrorMessage","errorType","qixError","item","type","message","qErrorString","_utils","_utils2","CONNECTION_ERROR","LOADING_ERROR","SYNTAX_ERROR","halyardMixin","types","init","args","config","api","Promise","extend","createSessionAppUsingHalyard","halyard","that","createSessionApp","then","app","setScriptAndReloadWithHalyard","createAppUsingHalyard","appName","createApp","appId","qAppId","openDoc","result","reloadAppUsingHalyard","existingAppName","createIfMissing","catch","error","COULD_NOT_FIND_APP","code","reject","appendToScriptAndReloadWithHalyard","doSaveAfterReload","deferredConnections","getConnections","forEach","connection","qixConnectionObject","getQixConnectionObject","connectionPromise","createConnection","err","LOCERR_CONNECTION_ALREADY_EXISTS","push","getScript","currentScript","newScript","all","getLocaleInfo","localeInfoResult","setDefaultSetStatements","globalApi","configureReload","setScript","doReload","getProgress","progressResult","qErrorData","length","checkScriptSyntax","syntaxCheckData","getItemThatGeneratedScriptAt","qTextPos","doSave","exposeGlobalApi","getObjectArgs","handle","genericType","customType","delta","session","getObjectApi","convertQixGetLocalInfo","localInfoData","ThousandSep","qThousandSep","DecimalSep","qDecimalSep","MoneyThousandSep","qMoneyThousandSep","MoneyDecimalSep","qMoneyDecimalSep","MoneyFormat","qMoneyFmt","TimeFormat","qTimeFmt","DateFormat","qDateFmt","TimestampFormat","qTimestampFmt","FirstWeekDay","qFirstWeekDay","ReferenceDay","qReferenceDay","FirstMonthOfYear","qFirstMonthOfYear","CollationLocale","qCollation","MonthNames","qCalendarStrings","qMonthNames","LongMonthNames","qLongMonthNames","DayNames","qDayNames","LongDayNames","qLongDayNames","Object","defineProperty","value"],"mappings":"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","file":"halyard-enigma-mixin.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"halyard-enigma-mixin\"] = factory();\n\telse\n\t\troot[\"halyard-enigma-mixin\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"halyard-enigma-mixin\"] = factory();\n\telse\n\t\troot[\"halyard-enigma-mixin\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _utils = __webpack_require__(1);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar CONNECTION_ERROR = 'Connection Error';\n\tvar LOADING_ERROR = 'Loading Error';\n\tvar SYNTAX_ERROR = 'Syntax Error';\n\t\n\tfunction createErrorMessage(errorType, qixError, item) {\n\t  return {\n\t    type: errorType,\n\t    message: qixError.message || qixError.qErrorString,\n\t    item: item,\n\t    qixError: qixError\n\t  };\n\t}\n\t\n\tvar halyardMixin = {\n\t  types: 'Global',\n\t  init: function init(args) {\n\t    if (args.config) {\n\t      args.api.Promise = args.config.Promise;\n\t    } else {\n\t      args.api.Promise = args.Promise;\n\t    }\n\t  },\n\t\n\t  extend: {\n\t    createSessionAppUsingHalyard: function createSessionAppUsingHalyard(halyard) {\n\t      var that = this;\n\t      return that.createSessionApp().then(function (app) {\n\t        return that.setScriptAndReloadWithHalyard(app, halyard, false);\n\t      });\n\t    },\n\t    createAppUsingHalyard: function createAppUsingHalyard(appName, halyard) {\n\t      var that = this;\n\t      return that.createApp(appName).then(function (app) {\n\t        var appId = app.qAppId;\n\t        return that.openDoc(appId).then(function (result) {\n\t          return that.setScriptAndReloadWithHalyard(result, halyard, true);\n\t        });\n\t      });\n\t    },\n\t    reloadAppUsingHalyard: function reloadAppUsingHalyard(existingAppName, halyard, createIfMissing) {\n\t      var that = this;\n\t      return that.openDoc(existingAppName).catch(function (error) {\n\t        var COULD_NOT_FIND_APP = 1003;\n\t\n\t        if (createIfMissing && error.code === COULD_NOT_FIND_APP) {\n\t          return that.createApp(existingAppName).then(function (app) {\n\t            return that.openDoc(app.qAppId);\n\t          });\n\t        }\n\t        return that.Promise.reject(error);\n\t      }).then(function (result) {\n\t        return that.setScriptAndReloadWithHalyard(result, halyard, true);\n\t      });\n\t    },\n\t    appendToScriptAndReloadWithHalyard: function appendToScriptAndReloadWithHalyard(appName, halyard, doSaveAfterReload) {\n\t      var that = this;\n\t      var deferredConnections = [];\n\t\n\t      return that.openDoc(appName).then(function (app) {\n\t        halyard.getConnections().forEach(function (connection) {\n\t          var qixConnectionObject = connection.getQixConnectionObject();\n\t          if (qixConnectionObject) {\n\t            var connectionPromise = app.createConnection(qixConnectionObject).then(function (result) {\n\t              return result;\n\t            }, function (err) {\n\t              var LOCERR_CONNECTION_ALREADY_EXISTS = 2000;\n\t\n\t              // Will not throw error if connection already exists.\n\t              // The connections guid makes the connections unique and we assumes that it\n\t              // is the same that was previously created\n\t              if (!(err.code && err.code === LOCERR_CONNECTION_ALREADY_EXISTS)) {\n\t                throw createErrorMessage(CONNECTION_ERROR, err, connection);\n\t              }\n\t            });\n\t\n\t            deferredConnections.push(connectionPromise);\n\t          }\n\t        });\n\t\n\t        return app.getScript().then(function (currentScript) {\n\t          var newScript = halyard.getScript();\n\t          return that.Promise.all(deferredConnections).then(function () {\n\t            return app.getLocaleInfo().then(function (localeInfoResult) {\n\t              halyard.setDefaultSetStatements((0, _utils2.default)(localeInfoResult), true);\n\t              return app.globalApi.configureReload(true, true, false).then(function () {\n\t                return app.setScript(currentScript + '\\n' + newScript).then(function () {\n\t                  return app.doReload().then(function () {\n\t                    return app.globalApi.getProgress(0).then(function (progressResult) {\n\t                      if (progressResult.qErrorData.length !== 0) {\n\t                        return app.checkScriptSyntax().then(function (syntaxCheckData) {\n\t                          if (syntaxCheckData.length === 0) {\n\t                            throw createErrorMessage(LOADING_ERROR, progressResult.qErrorData[0]);\n\t                          } else {\n\t                            var item = halyard.getItemThatGeneratedScriptAt(syntaxCheckData[0].qTextPos);\n\t                            throw createErrorMessage(SYNTAX_ERROR, progressResult.qErrorData[0], item);\n\t                          }\n\t                        });\n\t                      }\n\t\n\t                      if (doSaveAfterReload) {\n\t                        return app.doSave().then(function () {\n\t                          return app;\n\t                        });\n\t                      }\n\t\n\t                      return app;\n\t                    });\n\t                  });\n\t                });\n\t              });\n\t            });\n\t          });\n\t        });\n\t      });\n\t    },\n\t    setScriptAndReloadWithHalyard: function setScriptAndReloadWithHalyard(app, halyard, doSaveAfterReload) {\n\t      var that = this;\n\t      var deferredConnections = [];\n\t\n\t      halyard.getConnections().forEach(function (connection) {\n\t        var qixConnectionObject = connection.getQixConnectionObject();\n\t        if (qixConnectionObject) {\n\t          var connectionPromise = app.createConnection(qixConnectionObject).then(function (result) {\n\t            return result;\n\t          }, function (err) {\n\t            var LOCERR_CONNECTION_ALREADY_EXISTS = 2000;\n\t\n\t            // Will not throw error if connection already exists.\n\t            // The connections guid makes the connections unique and we assumes that it\n\t            // is the same that was previously created\n\t            if (!(err.code && err.code === LOCERR_CONNECTION_ALREADY_EXISTS)) {\n\t              throw createErrorMessage(CONNECTION_ERROR, err, connection);\n\t            }\n\t          });\n\t\n\t          deferredConnections.push(connectionPromise);\n\t        }\n\t      });\n\t\n\t      return that.Promise.all(deferredConnections).then(function () {\n\t        return app.getLocaleInfo().then(function (localeInfoResult) {\n\t          halyard.setDefaultSetStatements((0, _utils2.default)(localeInfoResult), true);\n\t          return app.globalApi.configureReload(true, true, false).then(function () {\n\t            return app.setScript(halyard.getScript()).then(function () {\n\t              return app.doReload().then(function () {\n\t                return app.globalApi.getProgress(0).then(function (progressResult) {\n\t                  if (progressResult.qErrorData.length !== 0) {\n\t                    return app.checkScriptSyntax().then(function (syntaxCheckData) {\n\t                      if (syntaxCheckData.length === 0) {\n\t                        throw createErrorMessage(LOADING_ERROR, progressResult.qErrorData[0]);\n\t                      } else {\n\t                        var item = halyard.getItemThatGeneratedScriptAt(syntaxCheckData[0].qTextPos);\n\t                        throw createErrorMessage(SYNTAX_ERROR, progressResult.qErrorData[0], item);\n\t                      }\n\t                    });\n\t                  }\n\t\n\t                  if (doSaveAfterReload) {\n\t                    return app.doSave().then(function () {\n\t                      return app;\n\t                    });\n\t                  }\n\t\n\t                  return app;\n\t                });\n\t              });\n\t            });\n\t          });\n\t        });\n\t      });\n\t    }\n\t  }\n\t};\n\t\n\tvar exposeGlobalApi = {\n\t  types: 'Doc',\n\t  init: function init(args) {\n\t    var getObjectArgs = {\n\t      handle: -1,\n\t      id: 'Global',\n\t      type: 'Global'\n\t    };\n\t    if (args.config) {\n\t      getObjectArgs.genericType = 'Global';\n\t    } else {\n\t      getObjectArgs.customType = 'Global';\n\t      getObjectArgs.delta = true;\n\t    }\n\t    args.api.globalApi = args.api.session.getObjectApi(getObjectArgs);\n\t  }\n\t};\n\t\n\tmodule.exports = [halyardMixin, exposeGlobalApi];\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = convertQixGetLocalInfo;\n\tfunction convertQixGetLocalInfo(localInfoData) {\n\t  return {\n\t    ThousandSep: localInfoData.qThousandSep,\n\t    DecimalSep: localInfoData.qDecimalSep,\n\t    MoneyThousandSep: localInfoData.qMoneyThousandSep,\n\t    MoneyDecimalSep: localInfoData.qMoneyDecimalSep,\n\t    MoneyFormat: localInfoData.qMoneyFmt,\n\t    TimeFormat: localInfoData.qTimeFmt,\n\t    DateFormat: localInfoData.qDateFmt,\n\t    TimestampFormat: localInfoData.qTimestampFmt,\n\t    FirstWeekDay: localInfoData.qFirstWeekDay,\n\t    ReferenceDay: localInfoData.qReferenceDay,\n\t    FirstMonthOfYear: localInfoData.qFirstMonthOfYear,\n\t    CollationLocale: localInfoData.qCollation,\n\t    MonthNames: localInfoData.qCalendarStrings.qMonthNames,\n\t    LongMonthNames: localInfoData.qCalendarStrings.qLongMonthNames,\n\t    DayNames: localInfoData.qCalendarStrings.qDayNames,\n\t    LongDayNames: localInfoData.qCalendarStrings.qLongDayNames\n\t  };\n\t}\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// halyard-enigma-mixin.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c92312525bb2357f1de0","import convertQixGetLocalInfo from './utils';\n\nconst CONNECTION_ERROR = 'Connection Error';\nconst LOADING_ERROR = 'Loading Error';\nconst SYNTAX_ERROR = 'Syntax Error';\n\nfunction createErrorMessage(errorType, qixError, item) {\n  return {\n    type: errorType,\n    message: qixError.message || qixError.qErrorString,\n    item,\n    qixError,\n  };\n}\n\nconst halyardMixin = {\n  types: 'Global',\n  init(args) {\n    if (args.config) {\n      args.api.Promise = args.config.Promise;\n    } else {\n      args.api.Promise = args.Promise;\n    }\n  },\n  extend: {\n    createSessionAppUsingHalyard(halyard) {\n      const that = this;\n      return that.createSessionApp().then(app =>\n        that.setScriptAndReloadWithHalyard(app, halyard, false));\n    },\n\n    createAppUsingHalyard(appName, halyard) {\n      const that = this;\n      return that.createApp(appName).then((app) => {\n        const appId = app.qAppId;\n        return that.openDoc(appId).then(result =>\n          that.setScriptAndReloadWithHalyard(result, halyard, true));\n      });\n    },\n\n    reloadAppUsingHalyard(existingAppName, halyard, createIfMissing) {\n      const that = this;\n      return that.openDoc(existingAppName)\n        .catch((error) => {\n          const COULD_NOT_FIND_APP = 1003;\n\n          if (createIfMissing && error.code === COULD_NOT_FIND_APP) {\n            return that.createApp(existingAppName).then(app => that.openDoc(app.qAppId));\n          }\n          return that.Promise.reject(error);\n        })\n        .then(result => that.setScriptAndReloadWithHalyard(result, halyard, true));\n    },\n\n    appendToScriptAndReloadWithHalyard(appName, halyard, doSaveAfterReload) {\n      const that = this;\n      const deferredConnections = [];\n\n      return that.openDoc(appName).then((app) => {\n        halyard.getConnections().forEach((connection) => {\n          const qixConnectionObject = connection.getQixConnectionObject();\n          if (qixConnectionObject) {\n            const connectionPromise = app.createConnection(qixConnectionObject)\n            .then(result => result, (err) => {\n              const LOCERR_CONNECTION_ALREADY_EXISTS = 2000;\n\n              // Will not throw error if connection already exists.\n              // The connections guid makes the connections unique and we assumes that it\n              // is the same that was previously created\n              if (!(err.code && err.code === LOCERR_CONNECTION_ALREADY_EXISTS)) {\n                throw createErrorMessage(CONNECTION_ERROR, err, connection);\n              }\n            });\n\n            deferredConnections.push(connectionPromise);\n          }\n        });\n\n        return app.getScript().then((currentScript) => {\n          const newScript = halyard.getScript();\n          return that.Promise.all(deferredConnections).then(() =>\n            app.getLocaleInfo().then((localeInfoResult) => {\n              halyard.setDefaultSetStatements(convertQixGetLocalInfo(localeInfoResult), true);\n              return app.globalApi.configureReload(true, true, false).then(\n                () => app.setScript(`${currentScript}\\n${newScript}`).then(\n                  () => app.doReload().then(() => app.globalApi.getProgress(0).then(\n                    (progressResult) => {\n                      if (progressResult.qErrorData.length !== 0) {\n                        return app.checkScriptSyntax().then((syntaxCheckData) => {\n                          if (syntaxCheckData.length === 0) {\n                            throw createErrorMessage(LOADING_ERROR, progressResult.qErrorData[0]);\n                          } else {\n                            const item =\n                              halyard.getItemThatGeneratedScriptAt(syntaxCheckData[0].qTextPos);\n                            throw createErrorMessage(SYNTAX_ERROR,\n                              progressResult.qErrorData[0],\n                              item);\n                          }\n                        });\n                      }\n\n                      if (doSaveAfterReload) {\n                        return app.doSave().then(() => app);\n                      }\n\n                      return app;\n                    })\n                  )\n                )\n              );\n            })\n          );\n        });\n      });\n    },\n\n    setScriptAndReloadWithHalyard(app, halyard, doSaveAfterReload) {\n      const that = this;\n      const deferredConnections = [];\n\n      halyard.getConnections().forEach((connection) => {\n        const qixConnectionObject = connection.getQixConnectionObject();\n        if (qixConnectionObject) {\n          const connectionPromise = app.createConnection(qixConnectionObject)\n          .then(result => result, (err) => {\n            const LOCERR_CONNECTION_ALREADY_EXISTS = 2000;\n\n            // Will not throw error if connection already exists.\n            // The connections guid makes the connections unique and we assumes that it\n            // is the same that was previously created\n            if (!(err.code && err.code === LOCERR_CONNECTION_ALREADY_EXISTS)) {\n              throw createErrorMessage(CONNECTION_ERROR, err, connection);\n            }\n          });\n\n          deferredConnections.push(connectionPromise);\n        }\n      });\n\n      return that.Promise.all(deferredConnections).then(() =>\n        app.getLocaleInfo().then((localeInfoResult) => {\n          halyard.setDefaultSetStatements(convertQixGetLocalInfo(localeInfoResult), true);\n          return app.globalApi.configureReload(true, true, false).then(\n            () => app.setScript(halyard.getScript()).then(\n              () => app.doReload().then(() => app.globalApi.getProgress(0).then(\n                (progressResult) => {\n                  if (progressResult.qErrorData.length !== 0) {\n                    return app.checkScriptSyntax().then((syntaxCheckData) => {\n                      if (syntaxCheckData.length === 0) {\n                        throw createErrorMessage(LOADING_ERROR, progressResult.qErrorData[0]);\n                      } else {\n                        const item =\n                          halyard.getItemThatGeneratedScriptAt(syntaxCheckData[0].qTextPos);\n                        throw createErrorMessage(SYNTAX_ERROR, progressResult.qErrorData[0], item);\n                      }\n                    });\n                  }\n\n                  if (doSaveAfterReload) {\n                    return app.doSave().then(() => app);\n                  }\n\n                  return app;\n                })\n              )\n            )\n          );\n        })\n      );\n    },\n  },\n};\n\n\nconst exposeGlobalApi = {\n  types: 'Doc',\n  init(args) {\n    const getObjectArgs = {\n      handle: -1,\n      id: 'Global',\n      type: 'Global',\n    };\n    if (args.config) {\n      getObjectArgs.genericType = 'Global';\n    } else {\n      getObjectArgs.customType = 'Global';\n      getObjectArgs.delta = true;\n    }\n    args.api.globalApi = args.api.session.getObjectApi(getObjectArgs);\n  },\n};\n\nmodule.exports = [halyardMixin, exposeGlobalApi];\n\n\n\n// WEBPACK FOOTER //\n// ./src/enigma-mixin/halyard-enigma-mixin.js","export default function convertQixGetLocalInfo(localInfoData) {\n  return {\n    ThousandSep: localInfoData.qThousandSep,\n    DecimalSep: localInfoData.qDecimalSep,\n    MoneyThousandSep: localInfoData.qMoneyThousandSep,\n    MoneyDecimalSep: localInfoData.qMoneyDecimalSep,\n    MoneyFormat: localInfoData.qMoneyFmt,\n    TimeFormat: localInfoData.qTimeFmt,\n    DateFormat: localInfoData.qDateFmt,\n    TimestampFormat: localInfoData.qTimestampFmt,\n    FirstWeekDay: localInfoData.qFirstWeekDay,\n    ReferenceDay: localInfoData.qReferenceDay,\n    FirstMonthOfYear: localInfoData.qFirstMonthOfYear,\n    CollationLocale: localInfoData.qCollation,\n    MonthNames: localInfoData.qCalendarStrings.qMonthNames,\n    LongMonthNames: localInfoData.qCalendarStrings.qLongMonthNames,\n    DayNames: localInfoData.qCalendarStrings.qDayNames,\n    LongDayNames: localInfoData.qCalendarStrings.qLongDayNames,\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enigma-mixin/utils.js"],"sourceRoot":""}